1. POD的初始化有点怪，比如上例，new A; 和new A(); 是不一样的，对于其内部的m，前者没有被初始化，后者被初始化了（不同 的编译器行为不一样，VC++和GCC不一样）。而非POD的初始化，则都会被初始化
2. 右值引用数值常量时，会占用一个变量，可查看汇编： static_cast<int&&>(0);
3. 具有 ``静态'' 生存期的未初始化变量  (即, 在函数外声明的变量和 有静态存储类型的变量) 可以确保初始值为零, 就像程序员键入了  ``=0'' 一样。因此, 这些变量如果是指针会被初始化为正确的空指 针, 如果是浮点数会被初始化为 0.0 (或正确的类型, 参见第 5 章)。
   具有 ``自动'' 生存期的变量 (即, 没有静态存储类型的局部变量) 如 果没有显示地初始化, 则包含的是垃圾内容。对垃圾内容不能作 任何有用的假设。
   这些规则也适用于数组和结构 (称为 ``聚合体'' ); 对于初始化来说, 数组和结构都被认为是 ``变量''。
   用 malloc() 和 realloc() 动态分配的内存也可能 包含垃圾数据, 因此必须由调用者正确地初始化。用 calloc()  获得的内存为全零, 但这对指针和浮点值不一定有用
   debug中会自动给变量初始化found=FALSE,而在release版中则不会。所以尽可能的给变量、类或结构初始
4. 使用POD的好处:
   字节赋值，可以安全的使用memset和memcpy对POD类型进行初始化和拷贝等等操作
   提供对C的内存布局兼容.
   保证了静态初始化的安全有效。静态初始化很多时候能提高程序性能，而POD类型的对象初始化往往更简单(比如放入目标文件的.bss段，在初始化中直接被赋值0).
5. Range-for statement 通过汇编发现是通过begin, end 和 operator* 来实现的
6. By default, a class has 5 operations， copy assignment， copy constructor， move assignment， move constructor, destructor